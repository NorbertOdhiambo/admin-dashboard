{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar elements = require('../elements/index');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n  hover: {\n    mode: 'label'\n  },\n  scales: {\n    xAxes: [{\n      type: 'category',\n      // Specific to Bar Controller\n      categoryPercentage: 0.8,\n      barPercentage: 0.9,\n      // offset settings\n      offset: true,\n      // grid line settings\n      gridLines: {\n        offsetGridLines: true\n      }\n    }],\n    yAxes: [{\n      type: 'linear'\n    }]\n  }\n});\n\ndefaults._set('horizontalBar', {\n  hover: {\n    mode: 'index',\n    axis: 'y'\n  },\n  scales: {\n    xAxes: [{\n      type: 'linear',\n      position: 'bottom'\n    }],\n    yAxes: [{\n      position: 'left',\n      type: 'category',\n      // Specific to Horizontal Bar Controller\n      categoryPercentage: 0.8,\n      barPercentage: 0.9,\n      // offset settings\n      offset: true,\n      // grid line settings\n      gridLines: {\n        offsetGridLines: true\n      }\n    }]\n  },\n  elements: {\n    rectangle: {\n      borderSkipped: 'left'\n    }\n  },\n  tooltips: {\n    callbacks: {\n      title: function (item, data) {\n        // Pick first xLabel for now\n        var title = '';\n\n        if (item.length > 0) {\n          if (item[0].yLabel) {\n            title = item[0].yLabel;\n          } else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n            title = data.labels[item[0].index];\n          }\n        }\n\n        return title;\n      },\n      label: function (item, data) {\n        var datasetLabel = data.datasets[item.datasetIndex].label || '';\n        return datasetLabel + ': ' + item.xLabel;\n      }\n    },\n    mode: 'index',\n    axis: 'y'\n  }\n});\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\n\n\nfunction computeMinSampleSize(scale, pixels) {\n  var min = scale.isHorizontal() ? scale.width : scale.height;\n  var ticks = scale.getTicks();\n  var prev, curr, i, ilen;\n\n  for (i = 1, ilen = pixels.length; i < ilen; ++i) {\n    min = Math.min(min, pixels[i] - pixels[i - 1]);\n  }\n\n  for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    min = i > 0 ? Math.min(min, curr - prev) : min;\n    prev = curr;\n  }\n\n  return min;\n}\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\n\n\nfunction computeFitCategoryTraits(index, ruler, options) {\n  var thickness = options.barThickness;\n  var count = ruler.stackCount;\n  var curr = ruler.pixels[index];\n  var size, ratio;\n\n  if (helpers.isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * count;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / count,\n    ratio: ratio,\n    start: curr - size / 2\n  };\n}\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\n\n\nfunction computeFlexCategoryTraits(index, ruler, options) {\n  var pixels = ruler.pixels;\n  var curr = pixels[index];\n  var prev = index > 0 ? pixels[index - 1] : null;\n  var next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  var percent = options.categoryPercentage;\n  var start, size;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale end extremity.\n    prev = curr - (next === null ? ruler.end - curr : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  start = curr - (curr - prev) / 2 * percent;\n  size = (next - prev) / 2 * percent;\n  return {\n    chunk: size / ruler.stackCount,\n    ratio: options.barPercentage,\n    start: start\n  };\n}\n\nmodule.exports = function (Chart) {\n  Chart.controllers.bar = Chart.DatasetController.extend({\n    dataElementType: elements.Rectangle,\n    initialize: function () {\n      var me = this;\n      var meta;\n      Chart.DatasetController.prototype.initialize.apply(me, arguments);\n      meta = me.getMeta();\n      meta.stack = me.getDataset().stack;\n      meta.bar = true;\n    },\n    update: function (reset) {\n      var me = this;\n      var rects = me.getMeta().data;\n      var i, ilen;\n      me._ruler = me.getRuler();\n\n      for (i = 0, ilen = rects.length; i < ilen; ++i) {\n        me.updateElement(rects[i], i, reset);\n      }\n    },\n    updateElement: function (rectangle, index, reset) {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var dataset = me.getDataset();\n      var custom = rectangle.custom || {};\n      var rectangleOptions = chart.options.elements.rectangle;\n      rectangle._xScale = me.getScaleForId(meta.xAxisID);\n      rectangle._yScale = me.getScaleForId(meta.yAxisID);\n      rectangle._datasetIndex = me.index;\n      rectangle._index = index;\n      rectangle._model = {\n        datasetLabel: dataset.label,\n        label: chart.data.labels[index],\n        borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n        borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n      };\n      me.updateElementGeometry(rectangle, index, reset);\n      rectangle.pivot();\n    },\n\n    /**\n     * @private\n     */\n    updateElementGeometry: function (rectangle, index, reset) {\n      var me = this;\n      var model = rectangle._model;\n      var vscale = me.getValueScale();\n      var base = vscale.getBasePixel();\n      var horizontal = vscale.isHorizontal();\n      var ruler = me._ruler || me.getRuler();\n      var vpixels = me.calculateBarValuePixels(me.index, index);\n      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n      model.horizontal = horizontal;\n      model.base = reset ? base : vpixels.base;\n      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n      model.height = horizontal ? ipixels.size : undefined;\n      model.width = horizontal ? undefined : ipixels.size;\n    },\n\n    /**\n     * @private\n     */\n    getValueScaleId: function () {\n      return this.getMeta().yAxisID;\n    },\n\n    /**\n     * @private\n     */\n    getIndexScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\n     * @private\n     */\n    getValueScale: function () {\n      return this.getScaleForId(this.getValueScaleId());\n    },\n\n    /**\n     * @private\n     */\n    getIndexScale: function () {\n      return this.getScaleForId(this.getIndexScaleId());\n    },\n\n    /**\n     * Returns the stacks based on groups and bar visibility.\n     * @param {Number} [last] - The dataset index\n     * @returns {Array} The stack list\n     * @private\n     */\n    _getStacks: function (last) {\n      var me = this;\n      var chart = me.chart;\n      var scale = me.getIndexScale();\n      var stacked = scale.options.stacked;\n      var ilen = last === undefined ? chart.data.datasets.length : last + 1;\n      var stacks = [];\n      var i, meta;\n\n      for (i = 0; i < ilen; ++i) {\n        meta = chart.getDatasetMeta(i);\n\n        if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {\n          stacks.push(meta.stack);\n        }\n      }\n\n      return stacks;\n    },\n\n    /**\n     * Returns the effective number of stacks based on groups and bar visibility.\n     * @private\n     */\n    getStackCount: function () {\n      return this._getStacks().length;\n    },\n\n    /**\n     * Returns the stack index for the given dataset based on groups and bar visibility.\n     * @param {Number} [datasetIndex] - The dataset index\n     * @param {String} [name] - The stack name to find\n     * @returns {Number} The stack index\n     * @private\n     */\n    getStackIndex: function (datasetIndex, name) {\n      var stacks = this._getStacks(datasetIndex);\n\n      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present\n\n      return index === -1 ? stacks.length - 1 : index;\n    },\n\n    /**\n     * @private\n     */\n    getRuler: function () {\n      var me = this;\n      var scale = me.getIndexScale();\n      var stackCount = me.getStackCount();\n      var datasetIndex = me.index;\n      var isHorizontal = scale.isHorizontal();\n      var start = isHorizontal ? scale.left : scale.top;\n      var end = start + (isHorizontal ? scale.width : scale.height);\n      var pixels = [];\n      var i, ilen, min;\n\n      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n        pixels.push(scale.getPixelForValue(null, i, datasetIndex));\n      }\n\n      min = helpers.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;\n      return {\n        min: min,\n        pixels: pixels,\n        start: start,\n        end: end,\n        stackCount: stackCount,\n        scale: scale\n      };\n    },\n\n    /**\n     * Note: pixel values are not clamped to the scale area.\n     * @private\n     */\n    calculateBarValuePixels: function (datasetIndex, index) {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var scale = me.getValueScale();\n      var datasets = chart.data.datasets;\n      var value = scale.getRightValue(datasets[datasetIndex].data[index]);\n      var stacked = scale.options.stacked;\n      var stack = meta.stack;\n      var start = 0;\n      var i, imeta, ivalue, base, head, size;\n\n      if (stacked || stacked === undefined && stack !== undefined) {\n        for (i = 0; i < datasetIndex; ++i) {\n          imeta = chart.getDatasetMeta(i);\n\n          if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {\n            ivalue = scale.getRightValue(datasets[i].data[index]);\n\n            if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {\n              start += ivalue;\n            }\n          }\n        }\n      }\n\n      base = scale.getPixelForValue(start);\n      head = scale.getPixelForValue(start + value);\n      size = (head - base) / 2;\n      return {\n        size: size,\n        base: base,\n        head: head,\n        center: head + size / 2\n      };\n    },\n\n    /**\n     * @private\n     */\n    calculateBarIndexPixels: function (datasetIndex, index, ruler) {\n      var me = this;\n      var options = ruler.scale.options;\n      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);\n      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n      var center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      var size = Math.min(helpers.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);\n      return {\n        base: center - size / 2,\n        head: center + size / 2,\n        center: center,\n        size: size\n      };\n    },\n    draw: function () {\n      var me = this;\n      var chart = me.chart;\n      var scale = me.getValueScale();\n      var rects = me.getMeta().data;\n      var dataset = me.getDataset();\n      var ilen = rects.length;\n      var i = 0;\n      helpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n      for (; i < ilen; ++i) {\n        if (!isNaN(scale.getRightValue(dataset.data[i]))) {\n          rects[i].draw();\n        }\n      }\n\n      helpers.canvas.unclipArea(chart.ctx);\n    }\n  });\n  Chart.controllers.horizontalBar = Chart.controllers.bar.extend({\n    /**\n     * @private\n     */\n    getValueScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\n     * @private\n     */\n    getIndexScaleId: function () {\n      return this.getMeta().yAxisID;\n    }\n  });\n};","map":{"version":3,"names":["defaults","require","elements","helpers","_set","hover","mode","scales","xAxes","type","categoryPercentage","barPercentage","offset","gridLines","offsetGridLines","yAxes","axis","position","rectangle","borderSkipped","tooltips","callbacks","title","item","data","length","yLabel","labels","index","label","datasetLabel","datasets","datasetIndex","xLabel","computeMinSampleSize","scale","pixels","min","isHorizontal","width","height","ticks","getTicks","prev","curr","i","ilen","Math","getPixelForTick","computeFitCategoryTraits","ruler","options","thickness","barThickness","count","stackCount","size","ratio","isNullOrUndef","chunk","start","computeFlexCategoryTraits","next","percent","end","module","exports","Chart","controllers","bar","DatasetController","extend","dataElementType","Rectangle","initialize","me","meta","prototype","apply","arguments","getMeta","stack","getDataset","update","reset","rects","_ruler","getRuler","updateElement","chart","dataset","custom","rectangleOptions","_xScale","getScaleForId","xAxisID","_yScale","yAxisID","_datasetIndex","_index","_model","backgroundColor","valueAtIndexOrDefault","borderColor","borderWidth","updateElementGeometry","pivot","model","vscale","getValueScale","base","getBasePixel","horizontal","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","x","head","center","y","undefined","getValueScaleId","getIndexScaleId","getIndexScale","_getStacks","last","stacked","stacks","getDatasetMeta","isDatasetVisible","indexOf","push","getStackCount","getStackIndex","name","left","top","getPixelForValue","value","getRightValue","imeta","ivalue","controller","id","range","stackIndex","valueOrDefault","maxBarThickness","Infinity","draw","canvas","clipArea","ctx","chartArea","isNaN","unclipArea","horizontalBar"],"sources":["C:/xampp/htdocs/essay-helpers/admin_dashboard/node_modules/chart.js/src/controllers/controller.bar.js"],"sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\ndefaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\tposition: 'left',\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Horizontal Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function(item, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\n\t\t\t\tif (item.length > 0) {\n\t\t\t\t\tif (item[0].yLabel) {\n\t\t\t\t\t\ttitle = item[0].yLabel;\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\n\t\t\t}\n\t\t},\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale end extremity.\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - ((curr - prev) / 2) * percent;\n\tsize = ((next - prev) / 2) * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {Number} [last] - The dataset index\n\t\t * @returns {Array} The stack list\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks;\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {Number} [datasetIndex] - The dataset index\n\t\t * @param {String} [name] - The stack name to find\n\t\t * @returns {Number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\t});\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}