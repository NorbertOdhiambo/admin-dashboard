{"ast":null,"code":"'use strict';\n\nvar Scale = require('../core/core.scale');\n\nvar scaleService = require('../core/core.scaleService');\n\nmodule.exports = function () {\n  // Default config for a category scale\n  var defaultConfig = {\n    position: 'bottom'\n  };\n  var DatasetScale = Scale.extend({\n    /**\n    * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n    * else fall back to data.labels\n    * @private\n    */\n    getLabels: function () {\n      var data = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var labels = me.getLabels();\n      me.minIndex = 0;\n      me.maxIndex = labels.length - 1;\n      var findIndex;\n\n      if (me.options.ticks.min !== undefined) {\n        // user specified min value\n        findIndex = labels.indexOf(me.options.ticks.min);\n        me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n      }\n\n      if (me.options.ticks.max !== undefined) {\n        // user specified max value\n        findIndex = labels.indexOf(me.options.ticks.max);\n        me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n      }\n\n      me.min = labels[me.minIndex];\n      me.max = labels[me.maxIndex];\n    },\n    buildTicks: function () {\n      var me = this;\n      var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array\n\n      me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var data = me.chart.data;\n      var isHorizontal = me.isHorizontal();\n\n      if (data.yLabels && !isHorizontal) {\n        return me.getRightValue(data.datasets[datasetIndex].data[index]);\n      }\n\n      return me.ticks[index - me.minIndex];\n    },\n    // Used to get data value locations.  Value can either be an index or a numerical value\n    getPixelForValue: function (value, index) {\n      var me = this;\n      var offset = me.options.offset; // 1 is added because we need the length but we have the indexes\n\n      var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,\n      // not the index of the scale. We need to change that.\n\n      var valueCategory;\n\n      if (value !== undefined && value !== null) {\n        valueCategory = me.isHorizontal() ? value.x : value.y;\n      }\n\n      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {\n        var labels = me.getLabels();\n        value = valueCategory || value;\n        var idx = labels.indexOf(value);\n        index = idx !== -1 ? idx : index;\n      }\n\n      if (me.isHorizontal()) {\n        var valueWidth = me.width / offsetAmt;\n        var widthOffset = valueWidth * (index - me.minIndex);\n\n        if (offset) {\n          widthOffset += valueWidth / 2;\n        }\n\n        return me.left + Math.round(widthOffset);\n      }\n\n      var valueHeight = me.height / offsetAmt;\n      var heightOffset = valueHeight * (index - me.minIndex);\n\n      if (offset) {\n        heightOffset += valueHeight / 2;\n      }\n\n      return me.top + Math.round(heightOffset);\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var offset = me.options.offset;\n      var value;\n      var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n      var horz = me.isHorizontal();\n      var valueDimension = (horz ? me.width : me.height) / offsetAmt;\n      pixel -= horz ? me.left : me.top;\n\n      if (offset) {\n        pixel -= valueDimension / 2;\n      }\n\n      if (pixel <= 0) {\n        value = 0;\n      } else {\n        value = Math.round(pixel / valueDimension);\n      }\n\n      return value + me.minIndex;\n    },\n    getBasePixel: function () {\n      return this.bottom;\n    }\n  });\n  scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n};","map":{"version":3,"names":["Scale","require","scaleService","module","exports","defaultConfig","position","DatasetScale","extend","getLabels","data","chart","options","labels","isHorizontal","xLabels","yLabels","determineDataLimits","me","minIndex","maxIndex","length","findIndex","ticks","min","undefined","indexOf","max","buildTicks","slice","getLabelForIndex","index","datasetIndex","getRightValue","datasets","getPixelForValue","value","offset","offsetAmt","Math","valueCategory","x","y","isNaN","idx","valueWidth","width","widthOffset","left","round","valueHeight","height","heightOffset","top","getPixelForTick","getValueForPixel","pixel","_ticks","horz","valueDimension","getBasePixel","bottom","registerScaleType"],"sources":["C:/xampp/htdocs/essay-helpers/admin_dashboard/node_modules/chart.js/src/scales/scale.category.js"],"sourcesContent":["'use strict';\n\nvar Scale = require('../core/core.scale');\nvar scaleService = require('../core/core.scaleService');\n\nmodule.exports = function() {\n\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('category', DatasetScale, defaultConfig);\n};\n"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,2BAAD,CAA1B;;AAEAE,MAAM,CAACC,OAAP,GAAiB,YAAW;EAE3B;EACA,IAAIC,aAAa,GAAG;IACnBC,QAAQ,EAAE;EADS,CAApB;EAIA,IAAIC,YAAY,GAAGP,KAAK,CAACQ,MAAN,CAAa;IAC/B;AACF;AACA;AACA;AACA;IACEC,SAAS,EAAE,YAAW;MACrB,IAAIC,IAAI,GAAG,KAAKC,KAAL,CAAWD,IAAtB;MACA,OAAO,KAAKE,OAAL,CAAaC,MAAb,KAAwB,KAAKC,YAAL,KAAsBJ,IAAI,CAACK,OAA3B,GAAqCL,IAAI,CAACM,OAAlE,KAA8EN,IAAI,CAACG,MAA1F;IACA,CAT8B;IAW/BI,mBAAmB,EAAE,YAAW;MAC/B,IAAIC,EAAE,GAAG,IAAT;MACA,IAAIL,MAAM,GAAGK,EAAE,CAACT,SAAH,EAAb;MACAS,EAAE,CAACC,QAAH,GAAc,CAAd;MACAD,EAAE,CAACE,QAAH,GAAcP,MAAM,CAACQ,MAAP,GAAgB,CAA9B;MACA,IAAIC,SAAJ;;MAEA,IAAIJ,EAAE,CAACN,OAAH,CAAWW,KAAX,CAAiBC,GAAjB,KAAyBC,SAA7B,EAAwC;QACvC;QACAH,SAAS,GAAGT,MAAM,CAACa,OAAP,CAAeR,EAAE,CAACN,OAAH,CAAWW,KAAX,CAAiBC,GAAhC,CAAZ;QACAN,EAAE,CAACC,QAAH,GAAcG,SAAS,KAAK,CAAC,CAAf,GAAmBA,SAAnB,GAA+BJ,EAAE,CAACC,QAAhD;MACA;;MAED,IAAID,EAAE,CAACN,OAAH,CAAWW,KAAX,CAAiBI,GAAjB,KAAyBF,SAA7B,EAAwC;QACvC;QACAH,SAAS,GAAGT,MAAM,CAACa,OAAP,CAAeR,EAAE,CAACN,OAAH,CAAWW,KAAX,CAAiBI,GAAhC,CAAZ;QACAT,EAAE,CAACE,QAAH,GAAcE,SAAS,KAAK,CAAC,CAAf,GAAmBA,SAAnB,GAA+BJ,EAAE,CAACE,QAAhD;MACA;;MAEDF,EAAE,CAACM,GAAH,GAASX,MAAM,CAACK,EAAE,CAACC,QAAJ,CAAf;MACAD,EAAE,CAACS,GAAH,GAASd,MAAM,CAACK,EAAE,CAACE,QAAJ,CAAf;IACA,CAhC8B;IAkC/BQ,UAAU,EAAE,YAAW;MACtB,IAAIV,EAAE,GAAG,IAAT;MACA,IAAIL,MAAM,GAAGK,EAAE,CAACT,SAAH,EAAb,CAFsB,CAGtB;;MACAS,EAAE,CAACK,KAAH,GAAYL,EAAE,CAACC,QAAH,KAAgB,CAAhB,IAAqBD,EAAE,CAACE,QAAH,KAAgBP,MAAM,CAACQ,MAAP,GAAgB,CAAtD,GAA2DR,MAA3D,GAAoEA,MAAM,CAACgB,KAAP,CAAaX,EAAE,CAACC,QAAhB,EAA0BD,EAAE,CAACE,QAAH,GAAc,CAAxC,CAA/E;IACA,CAvC8B;IAyC/BU,gBAAgB,EAAE,UAASC,KAAT,EAAgBC,YAAhB,EAA8B;MAC/C,IAAId,EAAE,GAAG,IAAT;MACA,IAAIR,IAAI,GAAGQ,EAAE,CAACP,KAAH,CAASD,IAApB;MACA,IAAII,YAAY,GAAGI,EAAE,CAACJ,YAAH,EAAnB;;MAEA,IAAIJ,IAAI,CAACM,OAAL,IAAgB,CAACF,YAArB,EAAmC;QAClC,OAAOI,EAAE,CAACe,aAAH,CAAiBvB,IAAI,CAACwB,QAAL,CAAcF,YAAd,EAA4BtB,IAA5B,CAAiCqB,KAAjC,CAAjB,CAAP;MACA;;MACD,OAAOb,EAAE,CAACK,KAAH,CAASQ,KAAK,GAAGb,EAAE,CAACC,QAApB,CAAP;IACA,CAlD8B;IAoD/B;IACAgB,gBAAgB,EAAE,UAASC,KAAT,EAAgBL,KAAhB,EAAuB;MACxC,IAAIb,EAAE,GAAG,IAAT;MACA,IAAImB,MAAM,GAAGnB,EAAE,CAACN,OAAH,CAAWyB,MAAxB,CAFwC,CAGxC;;MACA,IAAIC,SAAS,GAAGC,IAAI,CAACZ,GAAL,CAAUT,EAAE,CAACE,QAAH,GAAc,CAAd,GAAkBF,EAAE,CAACC,QAArB,IAAiCkB,MAAM,GAAG,CAAH,GAAO,CAA9C,CAAV,EAA6D,CAA7D,CAAhB,CAJwC,CAMxC;MACA;;MACA,IAAIG,aAAJ;;MACA,IAAIJ,KAAK,KAAKX,SAAV,IAAuBW,KAAK,KAAK,IAArC,EAA2C;QAC1CI,aAAa,GAAGtB,EAAE,CAACJ,YAAH,KAAoBsB,KAAK,CAACK,CAA1B,GAA8BL,KAAK,CAACM,CAApD;MACA;;MACD,IAAIF,aAAa,KAAKf,SAAlB,IAAgCW,KAAK,KAAKX,SAAV,IAAuBkB,KAAK,CAACZ,KAAD,CAAhE,EAA0E;QACzE,IAAIlB,MAAM,GAAGK,EAAE,CAACT,SAAH,EAAb;QACA2B,KAAK,GAAGI,aAAa,IAAIJ,KAAzB;QACA,IAAIQ,GAAG,GAAG/B,MAAM,CAACa,OAAP,CAAeU,KAAf,CAAV;QACAL,KAAK,GAAGa,GAAG,KAAK,CAAC,CAAT,GAAaA,GAAb,GAAmBb,KAA3B;MACA;;MAED,IAAIb,EAAE,CAACJ,YAAH,EAAJ,EAAuB;QACtB,IAAI+B,UAAU,GAAG3B,EAAE,CAAC4B,KAAH,GAAWR,SAA5B;QACA,IAAIS,WAAW,GAAIF,UAAU,IAAId,KAAK,GAAGb,EAAE,CAACC,QAAf,CAA7B;;QAEA,IAAIkB,MAAJ,EAAY;UACXU,WAAW,IAAKF,UAAU,GAAG,CAA7B;QACA;;QAED,OAAO3B,EAAE,CAAC8B,IAAH,GAAUT,IAAI,CAACU,KAAL,CAAWF,WAAX,CAAjB;MACA;;MACD,IAAIG,WAAW,GAAGhC,EAAE,CAACiC,MAAH,GAAYb,SAA9B;MACA,IAAIc,YAAY,GAAIF,WAAW,IAAInB,KAAK,GAAGb,EAAE,CAACC,QAAf,CAA/B;;MAEA,IAAIkB,MAAJ,EAAY;QACXe,YAAY,IAAKF,WAAW,GAAG,CAA/B;MACA;;MAED,OAAOhC,EAAE,CAACmC,GAAH,GAASd,IAAI,CAACU,KAAL,CAAWG,YAAX,CAAhB;IACA,CA1F8B;IA2F/BE,eAAe,EAAE,UAASvB,KAAT,EAAgB;MAChC,OAAO,KAAKI,gBAAL,CAAsB,KAAKZ,KAAL,CAAWQ,KAAX,CAAtB,EAAyCA,KAAK,GAAG,KAAKZ,QAAtD,EAAgE,IAAhE,CAAP;IACA,CA7F8B;IA8F/BoC,gBAAgB,EAAE,UAASC,KAAT,EAAgB;MACjC,IAAItC,EAAE,GAAG,IAAT;MACA,IAAImB,MAAM,GAAGnB,EAAE,CAACN,OAAH,CAAWyB,MAAxB;MACA,IAAID,KAAJ;MACA,IAAIE,SAAS,GAAGC,IAAI,CAACZ,GAAL,CAAUT,EAAE,CAACuC,MAAH,CAAUpC,MAAV,IAAoBgB,MAAM,GAAG,CAAH,GAAO,CAAjC,CAAV,EAAgD,CAAhD,CAAhB;MACA,IAAIqB,IAAI,GAAGxC,EAAE,CAACJ,YAAH,EAAX;MACA,IAAI6C,cAAc,GAAG,CAACD,IAAI,GAAGxC,EAAE,CAAC4B,KAAN,GAAc5B,EAAE,CAACiC,MAAtB,IAAgCb,SAArD;MAEAkB,KAAK,IAAIE,IAAI,GAAGxC,EAAE,CAAC8B,IAAN,GAAa9B,EAAE,CAACmC,GAA7B;;MAEA,IAAIhB,MAAJ,EAAY;QACXmB,KAAK,IAAKG,cAAc,GAAG,CAA3B;MACA;;MAED,IAAIH,KAAK,IAAI,CAAb,EAAgB;QACfpB,KAAK,GAAG,CAAR;MACA,CAFD,MAEO;QACNA,KAAK,GAAGG,IAAI,CAACU,KAAL,CAAWO,KAAK,GAAGG,cAAnB,CAAR;MACA;;MAED,OAAOvB,KAAK,GAAGlB,EAAE,CAACC,QAAlB;IACA,CAnH8B;IAoH/ByC,YAAY,EAAE,YAAW;MACxB,OAAO,KAAKC,MAAZ;IACA;EAtH8B,CAAb,CAAnB;EAyHA3D,YAAY,CAAC4D,iBAAb,CAA+B,UAA/B,EAA2CvD,YAA3C,EAAyDF,aAAzD;AACA,CAjID"},"metadata":{},"sourceType":"script"}