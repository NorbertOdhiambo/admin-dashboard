{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar Scale = require('../core/core.scale');\n\nvar scaleService = require('../core/core.scaleService');\n\nvar Ticks = require('../core/core.ticks');\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\n\n\nfunction generateTicks(generationOptions, dataRange) {\n  var ticks = [];\n  var valueOrDefault = helpers.valueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of\n  // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n  // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n  // the graph\n\n  var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n  var endExp = Math.floor(helpers.log10(dataRange.max));\n  var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  var exp, significand;\n\n  if (tickVal === 0) {\n    exp = Math.floor(helpers.log10(dataRange.minNotZero));\n    significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n    ticks.push(tickVal);\n    tickVal = significand * Math.pow(10, exp);\n  } else {\n    exp = Math.floor(helpers.log10(tickVal));\n    significand = Math.floor(tickVal / Math.pow(10, exp));\n  }\n\n  var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n  do {\n    ticks.push(tickVal);\n    ++significand;\n\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n  var lastTick = valueOrDefault(generationOptions.max, tickVal);\n  ticks.push(lastTick);\n  return ticks;\n}\n\nmodule.exports = function (Chart) {\n  var defaultConfig = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: Ticks.formatters.logarithmic\n    }\n  };\n  var LogarithmicScale = Scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // Calculate Range\n\n\n      me.min = null;\n      me.max = null;\n      me.minNotZero = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            helpers.each(dataset.data, function (rawValue, index) {\n              var values = valuesPerStack[key];\n              var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value) || meta.data[index].hidden || value < 0) {\n                return;\n              }\n\n              values[index] = values[index] || 0;\n              values[index] += value;\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          if (valuesForType.length > 0) {\n            var minVal = helpers.min(valuesForType);\n            var maxVal = helpers.max(valuesForType);\n            me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n          }\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value) || meta.data[index].hidden || value < 0) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n\n              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                me.minNotZero = value;\n              }\n            });\n          }\n        });\n      } // Common base implementation to handle ticks.min, ticks.max\n\n\n      this.handleTickRangeOptions();\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var valueOrDefault = helpers.valueOrDefault;\n      var DEFAULT_MIN = 1;\n      var DEFAULT_MAX = 10;\n      me.min = valueOrDefault(tickOpts.min, me.min);\n      me.max = valueOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n        } else {\n          me.min = DEFAULT_MIN;\n          me.max = DEFAULT_MAX;\n        }\n      }\n\n      if (me.min === null) {\n        me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n      }\n\n      if (me.max === null) {\n        me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1) : DEFAULT_MAX;\n      }\n\n      if (me.minNotZero === null) {\n        if (me.min > 0) {\n          me.minNotZero = me.min;\n        } else if (me.max < 1) {\n          me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n        } else {\n          me.minNotZero = DEFAULT_MIN;\n        }\n      }\n    },\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var reverse = !me.isHorizontal();\n      var generationOptions = {\n        min: tickOpts.min,\n        max: tickOpts.max\n      };\n      var ticks = me.ticks = generateTicks(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        reverse = !reverse;\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n\n      if (reverse) {\n        ticks.reverse();\n      }\n    },\n    convertTicksToLabels: function () {\n      this.tickValues = this.ticks.slice();\n      Scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.tickValues[index]);\n    },\n\n    /**\n     * Returns the value of the first tick.\n     * @param {Number} value - The minimum not zero value.\n     * @return {Number} The first tick value.\n     * @private\n     */\n    _getFirstTickValue: function (value) {\n      var exp = Math.floor(helpers.log10(value));\n      var significand = Math.floor(value / Math.pow(10, exp));\n      return significand * Math.pow(10, exp);\n    },\n    getPixelForValue: function (value) {\n      var me = this;\n      var reverse = me.options.ticks.reverse;\n      var log10 = helpers.log10;\n\n      var firstTickValue = me._getFirstTickValue(me.minNotZero);\n\n      var offset = 0;\n      var innerDimension, pixel, start, end, sign;\n      value = +me.getRightValue(value);\n\n      if (reverse) {\n        start = me.end;\n        end = me.start;\n        sign = -1;\n      } else {\n        start = me.start;\n        end = me.end;\n        sign = 1;\n      }\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        pixel = reverse ? me.right : me.left;\n      } else {\n        innerDimension = me.height;\n        sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\n        pixel = reverse ? me.top : me.bottom;\n      }\n\n      if (value !== start) {\n        if (start === 0) {\n          // include zero tick\n          offset = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n          innerDimension -= offset;\n          start = firstTickValue;\n        }\n\n        if (value !== 0) {\n          offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n        }\n\n        pixel += sign * offset;\n      }\n\n      return pixel;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var reverse = me.options.ticks.reverse;\n      var log10 = helpers.log10;\n\n      var firstTickValue = me._getFirstTickValue(me.minNotZero);\n\n      var innerDimension, start, end, value;\n\n      if (reverse) {\n        start = me.end;\n        end = me.start;\n      } else {\n        start = me.start;\n        end = me.end;\n      }\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        value = reverse ? me.right - pixel : pixel - me.left;\n      } else {\n        innerDimension = me.height;\n        value = reverse ? pixel - me.top : me.bottom - pixel;\n      }\n\n      if (value !== start) {\n        if (start === 0) {\n          // include zero tick\n          var offset = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n          value -= offset;\n          innerDimension -= offset;\n          start = firstTickValue;\n        }\n\n        value *= log10(end) - log10(start);\n        value /= innerDimension;\n        value = Math.pow(10, log10(start) + value);\n      }\n\n      return value;\n    }\n  });\n  scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};","map":{"version":3,"names":["helpers","require","Scale","scaleService","Ticks","generateTicks","generationOptions","dataRange","ticks","valueOrDefault","tickVal","min","Math","pow","floor","log10","endExp","max","endSignificand","ceil","exp","significand","minNotZero","push","precision","abs","round","lastTick","module","exports","Chart","defaultConfig","position","callback","formatters","logarithmic","LogarithmicScale","extend","determineDataLimits","me","opts","options","chart","data","datasets","isHorizontal","IDMatches","meta","xAxisID","id","yAxisID","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","rawValue","index","values","value","getRightValue","isNaN","hidden","valuesForType","length","minVal","maxVal","handleTickRangeOptions","tickOpts","DEFAULT_MIN","DEFAULT_MAX","buildTicks","reverse","start","end","convertTicksToLabels","tickValues","slice","prototype","call","getLabelForIndex","getPixelForTick","getPixelForValue","_getFirstTickValue","firstTickValue","offset","innerDimension","pixel","sign","width","right","left","height","top","bottom","getValueOrDefault","fontSize","defaults","global","defaultFontSize","getValueForPixel","registerScaleType"],"sources":["C:/xampp/htdocs/essay-helpers/admin_dashboard/node_modules/chart.js/src/scales/scale.logarithmic.js"],"sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\nvar Scale = require('../core/core.scale');\nvar scaleService = require('../core/core.scaleService');\nvar Ticks = require('../core/core.ticks');\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t// Figure out what the max number of ticks we can support it is based on the size of\n\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t// the graph\n\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tScale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {Number} value - The minimum not zero value.\n\t\t * @return {Number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}