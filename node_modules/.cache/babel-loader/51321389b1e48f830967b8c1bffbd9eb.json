{"ast":null,"code":"/* global window: false */\n'use strict';\n\nvar moment = require('moment');\n\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\n\nvar helpers = require('../helpers/index');\n\nvar Scale = require('../core/core.scale');\n\nvar scaleService = require('../core/core.scaleService'); // Integer constants are from the ES6 spec.\n\n\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n  return a - b;\n}\n\nfunction arrayUnique(items) {\n  var hash = {};\n  var out = [];\n  var i, ilen, item;\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    item = items[i];\n\n    if (!hash[item]) {\n      hash[item] = true;\n      out.push(item);\n    }\n  }\n\n  return out;\n}\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\n\n\nfunction buildLookupTable(timestamps, min, max, distribution) {\n  if (distribution === 'linear' || !timestamps.length) {\n    return [{\n      time: min,\n      pos: 0\n    }, {\n      time: max,\n      pos: 1\n    }];\n  }\n\n  var table = [];\n  var items = [min];\n  var i, ilen, prev, curr, next;\n\n  for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n    curr = timestamps[i];\n\n    if (curr > min && curr < max) {\n      items.push(curr);\n    }\n  }\n\n  items.push(max);\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    next = items[i + 1];\n    prev = items[i - 1];\n    curr = items[i]; // only add points that breaks the scale linearity\n\n    if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n      table.push({\n        time: curr,\n        pos: i / (ilen - 1)\n      });\n    }\n  }\n\n  return table;\n} // @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\n\n\nfunction lookup(table, key, value) {\n  var lo = 0;\n  var hi = table.length - 1;\n  var mid, i0, i1;\n\n  while (lo >= 0 && lo <= hi) {\n    mid = lo + hi >> 1;\n    i0 = table[mid - 1] || null;\n    i1 = table[mid];\n\n    if (!i0) {\n      // given value is outside table (before first item)\n      return {\n        lo: null,\n        hi: i1\n      };\n    } else if (i1[key] < value) {\n      lo = mid + 1;\n    } else if (i0[key] > value) {\n      hi = mid - 1;\n    } else {\n      return {\n        lo: i0,\n        hi: i1\n      };\n    }\n  } // given value is outside table (after last item)\n\n\n  return {\n    lo: i1,\n    hi: null\n  };\n}\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\n\n\nfunction interpolate(table, skey, sval, tkey) {\n  var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\n  var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n  var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n  var span = next[skey] - prev[skey];\n  var ratio = span ? (sval - prev[skey]) / span : 0;\n  var offset = (next[tkey] - prev[tkey]) * ratio;\n  return prev[tkey] + offset;\n}\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\n\n\nfunction momentify(value, options) {\n  var parser = options.parser;\n  var format = options.parser || options.format;\n\n  if (typeof parser === 'function') {\n    return parser(value);\n  }\n\n  if (typeof value === 'string' && typeof format === 'string') {\n    return moment(value, format);\n  }\n\n  if (!(value instanceof moment)) {\n    value = moment(value);\n  }\n\n  if (value.isValid()) {\n    return value;\n  } // Labels are in an incompatible moment format and no `parser` has been provided.\n  // The user might still use the deprecated `format` option to convert his inputs.\n\n\n  if (typeof format === 'function') {\n    return format(value);\n  }\n\n  return value;\n}\n\nfunction parse(input, scale) {\n  if (helpers.isNullOrUndef(input)) {\n    return null;\n  }\n\n  var options = scale.options.time;\n  var value = momentify(scale.getRightValue(input), options);\n\n  if (!value.isValid()) {\n    return null;\n  }\n\n  if (options.round) {\n    value.startOf(options.round);\n  }\n\n  return value.valueOf();\n}\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\n\n\nfunction determineStepSize(min, max, unit, capacity) {\n  var range = max - min;\n  var interval = INTERVALS[unit];\n  var milliseconds = interval.size;\n  var steps = interval.steps;\n  var i, ilen, factor;\n\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n\n  for (i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n\n  return factor;\n}\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\n\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  var ilen = UNITS.length;\n  var i, interval, factor;\n\n  for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    interval = INTERVALS[UNITS[i]];\n    factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n/**\n * Figures out what unit to format a set of ticks with\n */\n\n\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n  var duration = moment.duration(moment(max).diff(moment(min)));\n  var ilen = UNITS.length;\n  var i, unit;\n\n  for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n    unit = UNITS[i];\n\n    if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n  for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\n\n\nfunction generate(min, max, capacity, options) {\n  var timeOpts = options.time;\n  var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n  var major = determineMajorUnit(minor);\n  var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n  var weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n  var majorTicksEnabled = options.ticks.major.enabled;\n  var interval = INTERVALS[minor];\n  var first = moment(min);\n  var last = moment(max);\n  var ticks = [];\n  var time;\n\n  if (!stepSize) {\n    stepSize = determineStepSize(min, max, minor, capacity);\n  } // For 'week' unit, handle the first day of week option\n\n\n  if (weekday) {\n    first = first.isoWeekday(weekday);\n    last = last.isoWeekday(weekday);\n  } // Align first/last ticks on unit\n\n\n  first = first.startOf(weekday ? 'day' : minor);\n  last = last.startOf(weekday ? 'day' : minor); // Make sure that the last tick include max\n\n  if (last < max) {\n    last.add(1, minor);\n  }\n\n  time = moment(first);\n\n  if (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n    // Align the first tick on the previous `minor` unit aligned on the `major` unit:\n    // we first aligned time on the previous `major` unit then add the number of full\n    // stepSize there is between first and the previous major time.\n    time.startOf(major);\n    time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n  }\n\n  for (; time < last; time.add(stepSize, minor)) {\n    ticks.push(+time);\n  }\n\n  ticks.push(+time);\n  return ticks;\n}\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\n\n\nfunction computeOffsets(table, ticks, min, max, options) {\n  var left = 0;\n  var right = 0;\n  var upper, lower;\n\n  if (options.offset && ticks.length) {\n    if (!options.time.min) {\n      upper = ticks.length > 1 ? ticks[1] : max;\n      lower = ticks[0];\n      left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;\n    }\n\n    if (!options.time.max) {\n      upper = ticks[ticks.length - 1];\n      lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n      right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;\n    }\n  }\n\n  return {\n    left: left,\n    right: right\n  };\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n  var ticks = [];\n  var i, ilen, value, major;\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    value = values[i];\n    major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n    ticks.push({\n      value: value,\n      major: major\n    });\n  }\n\n  return ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n  var i, momentDate, hasTime;\n  var ilen = data.length; // find the label with the most parts (milliseconds, minutes, etc.)\n  // format all labels with the same level of detail as the most specific label\n\n  for (i = 0; i < ilen; i++) {\n    momentDate = momentify(data[i], timeOpts);\n\n    if (momentDate.millisecond() !== 0) {\n      return 'MMM D, YYYY h:mm:ss.SSS a';\n    }\n\n    if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n      hasTime = true;\n    }\n  }\n\n  if (hasTime) {\n    return 'MMM D, YYYY h:mm:ss a';\n  }\n\n  return 'MMM D, YYYY';\n}\n\nmodule.exports = function () {\n  var defaultConfig = {\n    position: 'bottom',\n\n    /**\n     * Data distribution along the scale:\n     * - 'linear': data are spread according to their time (distances can vary),\n     * - 'series': data are spread at the same distance from each other.\n     * @see https://github.com/chartjs/Chart.js/pull/4507\n     * @since 2.7.0\n     */\n    distribution: 'linear',\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n    time: {\n      parser: false,\n      // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n      format: false,\n      // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n      unit: false,\n      // false == automatic or override with week, month, year, etc.\n      round: false,\n      // none, or override with week, month, year, etc.\n      displayFormat: false,\n      // DEPRECATED\n      isoWeekday: false,\n      // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n      minUnit: 'millisecond',\n      // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n      displayFormats: {\n        millisecond: 'h:mm:ss.SSS a',\n        // 11:20:01.123 AM,\n        second: 'h:mm:ss a',\n        // 11:20:01 AM\n        minute: 'h:mm a',\n        // 11:20 AM\n        hour: 'hA',\n        // 5PM\n        day: 'MMM D',\n        // Sep 4\n        week: 'll',\n        // Week 46, or maybe \"[W]WW - YYYY\" ?\n        month: 'MMM YYYY',\n        // Sept 2015\n        quarter: '[Q]Q - YYYY',\n        // Q3\n        year: 'YYYY' // 2015\n\n      }\n    },\n    ticks: {\n      autoSkip: false,\n\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n      major: {\n        enabled: false\n      }\n    }\n  };\n  var TimeScale = Scale.extend({\n    initialize: function () {\n      if (!moment) {\n        throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n      }\n\n      this.mergeTicksOptions();\n      Scale.prototype.initialize.call(this);\n    },\n    update: function () {\n      var me = this;\n      var options = me.options; // DEPRECATIONS: output a message only one time per update\n\n      if (options.time && options.time.format) {\n        console.warn('options.time.format is deprecated and replaced by options.time.parser.');\n      }\n\n      return Scale.prototype.update.apply(me, arguments);\n    },\n\n    /**\n     * Allows data to be referenced via 't' attribute\n     */\n    getRightValue: function (rawValue) {\n      if (rawValue && rawValue.t !== undefined) {\n        rawValue = rawValue.t;\n      }\n\n      return Scale.prototype.getRightValue.call(this, rawValue);\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var timeOpts = me.options.time;\n      var unit = timeOpts.unit || 'day';\n      var min = MAX_INTEGER;\n      var max = MIN_INTEGER;\n      var timestamps = [];\n      var datasets = [];\n      var labels = [];\n      var i, j, ilen, jlen, data, timestamp; // Convert labels to timestamps\n\n      for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n        labels.push(parse(chart.data.labels[i], me));\n      } // Convert data to timestamps\n\n\n      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          data = chart.data.datasets[i].data; // Let's consider that all data have the same format.\n\n          if (helpers.isObject(data[0])) {\n            datasets[i] = [];\n\n            for (j = 0, jlen = data.length; j < jlen; ++j) {\n              timestamp = parse(data[j], me);\n              timestamps.push(timestamp);\n              datasets[i][j] = timestamp;\n            }\n          } else {\n            timestamps.push.apply(timestamps, labels);\n            datasets[i] = labels.slice(0);\n          }\n        } else {\n          datasets[i] = [];\n        }\n      }\n\n      if (labels.length) {\n        // Sort labels **after** data have been converted\n        labels = arrayUnique(labels).sort(sorter);\n        min = Math.min(min, labels[0]);\n        max = Math.max(max, labels[labels.length - 1]);\n      }\n\n      if (timestamps.length) {\n        timestamps = arrayUnique(timestamps).sort(sorter);\n        min = Math.min(min, timestamps[0]);\n        max = Math.max(max, timestamps[timestamps.length - 1]);\n      }\n\n      min = parse(timeOpts.min, me) || min;\n      max = parse(timeOpts.max, me) || max; // In case there is no valid min/max, set limits based on unit time option\n\n      min = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n      max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)\n\n      me.min = Math.min(min, max);\n      me.max = Math.max(min + 1, max); // PRIVATE\n\n      me._horizontal = me.isHorizontal();\n      me._table = [];\n      me._timestamps = {\n        data: timestamps,\n        datasets: datasets,\n        labels: labels\n      };\n    },\n    buildTicks: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      var options = me.options;\n      var timeOpts = options.time;\n      var timestamps = [];\n      var ticks = [];\n      var i, ilen, timestamp;\n\n      switch (options.ticks.source) {\n        case 'data':\n          timestamps = me._timestamps.data;\n          break;\n\n        case 'labels':\n          timestamps = me._timestamps.labels;\n          break;\n\n        case 'auto':\n        default:\n          timestamps = generate(min, max, me.getLabelCapacity(min), options);\n      }\n\n      if (options.bounds === 'ticks' && timestamps.length) {\n        min = timestamps[0];\n        max = timestamps[timestamps.length - 1];\n      } // Enforce limits with user min/max options\n\n\n      min = parse(timeOpts.min, me) || min;\n      max = parse(timeOpts.max, me) || max; // Remove ticks outside the min/max range\n\n      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n        timestamp = timestamps[i];\n\n        if (timestamp >= min && timestamp <= max) {\n          ticks.push(timestamp);\n        }\n      }\n\n      me.min = min;\n      me.max = max; // PRIVATE\n\n      me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n      me._majorUnit = determineMajorUnit(me._unit);\n      me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n      me._offsets = computeOffsets(me._table, ticks, min, max, options);\n      me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n      return ticksFromTimestamps(ticks, me._majorUnit);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var data = me.chart.data;\n      var timeOpts = me.options.time;\n      var label = data.labels && index < data.labels.length ? data.labels[index] : '';\n      var value = data.datasets[datasetIndex].data[index];\n\n      if (helpers.isObject(value)) {\n        label = me.getRightValue(value);\n      }\n\n      if (timeOpts.tooltipFormat) {\n        return momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n      }\n\n      if (typeof label === 'string') {\n        return label;\n      }\n\n      return momentify(label, timeOpts).format(me._labelFormat);\n    },\n\n    /**\n     * Function to format an individual tick mark\n     * @private\n     */\n    tickFormatFunction: function (tick, index, ticks, formatOverride) {\n      var me = this;\n      var options = me.options;\n      var time = tick.valueOf();\n      var formats = options.time.displayFormats;\n      var minorFormat = formats[me._unit];\n      var majorUnit = me._majorUnit;\n      var majorFormat = formats[majorUnit];\n      var majorTime = tick.clone().startOf(majorUnit).valueOf();\n      var majorTickOpts = options.ticks.major;\n      var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n      var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n      var tickOpts = major ? majorTickOpts : options.ticks.minor;\n      var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n      return formatter ? formatter(label, index, ticks) : label;\n    },\n    convertTicksToLabels: function (ticks) {\n      var labels = [];\n      var i, ilen;\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n      }\n\n      return labels;\n    },\n\n    /**\n     * @private\n     */\n    getPixelForOffset: function (time) {\n      var me = this;\n      var size = me._horizontal ? me.width : me.height;\n      var start = me._horizontal ? me.left : me.top;\n      var pos = interpolate(me._table, 'time', time, 'pos');\n      return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n    },\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var time = null;\n\n      if (index !== undefined && datasetIndex !== undefined) {\n        time = me._timestamps.datasets[datasetIndex][index];\n      }\n\n      if (time === null) {\n        time = parse(value, me);\n      }\n\n      if (time !== null) {\n        return me.getPixelForOffset(time);\n      }\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.getTicks();\n      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var size = me._horizontal ? me.width : me.height;\n      var start = me._horizontal ? me.left : me.top;\n      var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n      var time = interpolate(me._table, 'pos', pos, 'time');\n      return moment(time);\n    },\n\n    /**\n     * Crude approximation of what the label width might be\n     * @private\n     */\n    getLabelWidth: function (label) {\n      var me = this;\n      var ticksOpts = me.options.ticks;\n      var tickLabelWidth = me.ctx.measureText(label).width;\n      var angle = helpers.toRadians(ticksOpts.maxRotation);\n      var cosRotation = Math.cos(angle);\n      var sinRotation = Math.sin(angle);\n      var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n      return tickLabelWidth * cosRotation + tickFontSize * sinRotation;\n    },\n\n    /**\n     * @private\n     */\n    getLabelCapacity: function (exampleTime) {\n      var me = this;\n      var formatOverride = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation\n\n      var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n      var tickLabelWidth = me.getLabelWidth(exampleLabel);\n      var innerWidth = me.isHorizontal() ? me.width : me.height;\n      var capacity = Math.floor(innerWidth / tickLabelWidth);\n      return capacity > 0 ? capacity : 1;\n    }\n  });\n  scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};","map":{"version":3,"names":["moment","require","window","defaults","helpers","Scale","scaleService","MIN_INTEGER","Number","MIN_SAFE_INTEGER","MAX_INTEGER","MAX_SAFE_INTEGER","INTERVALS","millisecond","common","size","steps","second","minute","hour","day","week","month","quarter","year","UNITS","Object","keys","sorter","a","b","arrayUnique","items","hash","out","i","ilen","item","length","push","buildLookupTable","timestamps","min","max","distribution","time","pos","table","prev","curr","next","undefined","Math","round","lookup","key","value","lo","hi","mid","i0","i1","interpolate","skey","sval","tkey","range","span","ratio","offset","momentify","options","parser","format","isValid","parse","input","scale","isNullOrUndef","getRightValue","startOf","valueOf","determineStepSize","unit","capacity","interval","milliseconds","factor","ceil","determineUnitForAutoTicks","minUnit","indexOf","determineUnitForFormatting","ticks","duration","diff","as","determineMajorUnit","generate","timeOpts","minor","major","stepSize","valueOrDefault","unitStepSize","weekday","isoWeekday","majorTicksEnabled","enabled","first","last","add","computeOffsets","left","right","upper","lower","ticksFromTimestamps","values","majorUnit","determineLabelFormat","data","momentDate","hasTime","module","exports","defaultConfig","position","bounds","displayFormat","displayFormats","autoSkip","source","TimeScale","extend","initialize","Error","mergeTicksOptions","prototype","call","update","me","console","warn","apply","arguments","rawValue","t","determineDataLimits","chart","datasets","labels","j","jlen","timestamp","isDatasetVisible","isObject","slice","sort","endOf","_horizontal","isHorizontal","_table","_timestamps","buildTicks","getLabelCapacity","_unit","_majorUnit","_offsets","_labelFormat","getLabelForIndex","index","datasetIndex","label","tooltipFormat","tickFormatFunction","tick","formatOverride","formats","minorFormat","majorFormat","majorTime","clone","majorTickOpts","tickOpts","formatter","callback","userCallback","convertTicksToLabels","getPixelForOffset","width","height","start","top","getPixelForValue","getPixelForTick","getTicks","getValueForPixel","pixel","getLabelWidth","ticksOpts","tickLabelWidth","ctx","measureText","angle","toRadians","maxRotation","cosRotation","cos","sinRotation","sin","tickFontSize","fontSize","global","defaultFontSize","exampleTime","exampleLabel","innerWidth","floor","registerScaleType"],"sources":["C:/xampp/htdocs/essay-helpers/admin_dashboard/node_modules/chart.js/src/scales/scale.time.js"],"sourcesContent":["/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Scale = require('../core/core.scale');\nvar scaleService = require('../core/core.scaleService');\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\nfunction momentify(value, options) {\n\tvar parser = options.parser;\n\tvar format = options.parser || options.format;\n\n\tif (typeof parser === 'function') {\n\t\treturn parser(value);\n\t}\n\n\tif (typeof value === 'string' && typeof format === 'string') {\n\t\treturn moment(value, format);\n\t}\n\n\tif (!(value instanceof moment)) {\n\t\tvalue = moment(value);\n\t}\n\n\tif (value.isValid()) {\n\t\treturn value;\n\t}\n\n\t// Labels are in an incompatible moment format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option to convert his inputs.\n\tif (typeof format === 'function') {\n\t\treturn format(value);\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, scale) {\n\tif (helpers.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = momentify(scale.getRightValue(input), options);\n\tif (!value.isValid()) {\n\t\treturn null;\n\t}\n\n\tif (options.round) {\n\t\tvalue.startOf(options.round);\n\t}\n\n\treturn value.valueOf();\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n\tvar duration = moment.duration(moment(max).diff(moment(min)));\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(min, max, capacity, options) {\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = moment(min);\n\tvar last = moment(max);\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = first.isoWeekday(weekday);\n\t\tlast = last.isoWeekday(weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = first.startOf(weekday ? 'day' : minor);\n\tlast = last.startOf(weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast.add(1, minor);\n\t}\n\n\ttime = moment(first);\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime.startOf(major);\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time.add(stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar left = 0;\n\tvar right = 0;\n\tvar upper, lower;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\n\t\t\tlower = ticks[0];\n\t\t\tleft = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tupper = ticks[ticks.length - 1];\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n\t\t\tright = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t}\n\n\treturn {left: left, right: right};\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n\tvar i, momentDate, hasTime;\n\tvar ilen = data.length;\n\n\t// find the label with the most parts (milliseconds, minutes, etc.)\n\t// format all labels with the same level of detail as the most specific label\n\tfor (i = 0; i < ilen; i++) {\n\t\tmomentDate = momentify(data[i], timeOpts);\n\t\tif (momentDate.millisecond() !== 0) {\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\n\t\t}\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n\t\t\thasTime = true;\n\t\t}\n\t}\n\tif (hasTime) {\n\t\treturn 'MMM D, YYYY h:mm:ss a';\n\t}\n\treturn 'MMM D, YYYY';\n}\n\nmodule.exports = function() {\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm a', // 11:20 AM\n\t\t\t\thour: 'hA', // 5PM\n\t\t\t\tday: 'MMM D', // Sep 4\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\n\tvar TimeScale = Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tthis.mergeTicksOptions();\n\n\t\t\tScale.prototype.initialize.call(this);\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (options.time && options.time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\n\t\t\treturn Scale.prototype.update.apply(me, arguments);\n\t\t},\n\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn Scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(chart.data.labels[i], me));\n\t\t\t}\n\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\n\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\t\tif (helpers.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\n\t\t},\n\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(tick, index, ticks, formatOverride) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = tick.valueOf();\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = tick.clone().startOf(majorUnit).valueOf();\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\n\n\t\t\treturn start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n\t\t},\n\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(value, me);\n\t\t\t}\n\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\n\n\t\t\treturn moment(time);\n\t\t},\n\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tvar formatOverride = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('time', TimeScale, defaultConfig);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}